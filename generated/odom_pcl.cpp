/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: odom_pcl.idl
  Source: odom_pcl.cpp
  Cyclone DDS: v0.10.5

*****************************************************************/
#include "odom_pcl.hpp"

namespace org{
namespace eclipse{
namespace cyclonedds{
namespace core{
namespace cdr{

template<>
propvec &get_type_props<::odom_msgs::Time>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::sec
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::nanosec

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Header>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Time>(), extensibility::ext_appendable, false));  //::stamp
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Time>());  //internal contents of ::stamp
  props.push_back(entity_properties_t(1, 1, false, bb_unset, extensibility::ext_final, false));  //::frame_id

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Point>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::x
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::y
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::z

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Quaternion>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::x
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::y
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::z
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::w

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Pose>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Point>(), extensibility::ext_appendable, false));  //::position
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Point>());  //internal contents of ::position
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<::odom_msgs::Quaternion>(), extensibility::ext_appendable, false));  //::orientation
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Quaternion>());  //internal contents of ::orientation

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Twist>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Point>(), extensibility::ext_appendable, false));  //::linear
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Point>());  //internal contents of ::linear
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<::odom_msgs::Point>(), extensibility::ext_appendable, false));  //::angular
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Point>());  //internal contents of ::angular

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::PoseWithCovariance>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Pose>(), extensibility::ext_appendable, false));  //::pose
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Pose>());  //internal contents of ::pose
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::covariance

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::TwistWithCovariance>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Twist>(), extensibility::ext_appendable, false));  //::twist
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Twist>());  //internal contents of ::twist
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::covariance

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::Odometry>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Header>(), extensibility::ext_appendable, false));  //::header
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Header>());  //internal contents of ::header
  props.push_back(entity_properties_t(1, 1, false, bb_unset, extensibility::ext_final, false));  //::child_frame_id
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<::odom_msgs::PoseWithCovariance>(), extensibility::ext_appendable, false));  //::pose
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::PoseWithCovariance>());  //internal contents of ::pose
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<::odom_msgs::TwistWithCovariance>(), extensibility::ext_appendable, false));  //::twist
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::TwistWithCovariance>());  //internal contents of ::twist

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::PointField>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, bb_unset, extensibility::ext_final, false));  //::name
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::offset
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<uint8_t>(), extensibility::ext_final, false));  //::datatype
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::count

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::PointCloud2>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Header>(), extensibility::ext_appendable, false));  //::header
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Header>());  //internal contents of ::header
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::height
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::width
  props.push_back(entity_properties_t(1, 3, false, bb_unset, extensibility::ext_appendable, false));  //::fields
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::PointField>());  //internal contents of ::fields
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::is_bigendian
  props.push_back(entity_properties_t(1, 5, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::point_step
  props.push_back(entity_properties_t(1, 6, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::row_step
  props.push_back(entity_properties_t(1, 7, false, bb_unset, extensibility::ext_final, false));  //::data
  props.push_back(entity_properties_t(1, 8, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::is_dense

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
propvec &get_type_props<::odom_msgs::OdometryPointCloud>() {
  static thread_local std::mutex mtx;
  static thread_local propvec props;
  static thread_local entity_properties_t *props_end = nullptr;
  static thread_local std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed)) {
    auto ptr = props.data();
    while (ptr < props_end)
      (ptr++)->is_present = false;
    return props;
  }
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bb_unset, extensibility::ext_appendable));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<::odom_msgs::Odometry>(), extensibility::ext_appendable, false));  //::odom
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::Odometry>());  //internal contents of ::odom
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<::odom_msgs::PointCloud2>(), extensibility::ext_appendable, false));  //::pcl
  entity_properties_t::append_struct_contents(props, get_type_props<::odom_msgs::PointCloud2>());  //internal contents of ::pcl

  entity_properties_t::finish(props, keylist);
  props_end = props.data() + props.size();
  initialized.store(true, std::memory_order_release);
  return props;
}

} //namespace cdr
} //namespace core
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

